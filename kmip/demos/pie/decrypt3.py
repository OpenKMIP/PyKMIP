# Copyright (c) 2017 The Johns Hopkins University/Applied Physics Laboratory
# All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

import binascii
import logging
import optparse
import sys

from kmip.core import enums
from kmip.pie import client

# Real world example, assuming 'test' is a valid configuration:
#
# $ python kmip/demos/pie/encrypt.py -c test -m "My test message."
# INFO - Successfully created a new encryption key.
# INFO - Secret ID: 470
# INFO - Successfully activated the encryption key.
# INFO - Successfully encrypted the message.
# INFO - Cipher text: b'49cfacbb62659180c20dfbf9f7553488b3ea9ebeecd70ce2e5c4d4
# ece6def0d4'
# INFO - No autogenerated IV expected, since one was provided.
# INFO - Autogenerated IV: None
# $ python kmip/demos/pie/decrypt.py -c test -i 470 -m b'49cfacbb62659180c20df
# bf9f7553488b3ea9ebeecd70ce2e5c4d4ece6def0d4'
# INFO - Successfully decrypted the message.
# INFO - Plain text: 'My test message.'
### -------------------------------------------------------------
def build_console_logger(level):
    logger = logging.getLogger('demo')
    logger.setLevel(level)
    handler = logging.StreamHandler()
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    handler.setFormatter(formatter)
    logger.addHandler(handler)
    return logger

def build_cli_parser():
    # Build the argument parser and setup expected options
    parser = optparse.OptionParser(
        usage="%prog [options]",
        description="Run KMIP client operation")

    parser.add_option(
        "-u",
        "--username",
        action="store",
        type="str",
        default=None,
        dest="username",
        help="Username for KMIP server account")
    parser.add_option(
        "-p",
        "--password",
        action="store",
        type="str",
        default=None,
        dest="password",
        help="Password for KMIP server account")
    parser.add_option(
        "-c",
        "--config",
        action="store",
        type="str",
        default="client",
        dest="config",
        help="Client configuration group to load from configuration file")    
    parser.add_option(
        "-i",
        "--uuid",
        action="store",
        type="str",
        default=None,
        dest="uuid",
        help="The unique ID of the decryption key to use to decrypt the "
                "cipher text."
    )
    parser.add_option(
        "-m",
        "--message",
        action="store",
        type="str",
        default=None,
        dest="message",
        help="The cipher text to decrypt."
    )
    parser.add_option(
        "-d",
        "--mode",
        action="store",
        type="str",
        default="CBC",
        dest="mode",
        help="Mode for cipher text."
    )
    parser.add_option(
        "-a",
        "--padding",
        action="store",
        type="str",
        default="ANSI_X923",
        dest="padding",
        help="Padding for block cipher."
    )
    parser.add_option(
        "-v",
        "--iv",
        action="store",
        type="str",
        default=None,
        dest="iv",
        help="IV for block cipher."
    )
    return parser

if __name__ == '__main__':
    logger = build_console_logger(logging.INFO)

    # Build and parse arguments
    parser = build_cli_parser()
    opts, args = parser.parse_args(sys.argv[1:])
    config = opts.config
    uuid = opts.uuid
    padding = opts.padding
    mode = opts.mode
    message = opts.message    
    iv = opts.iv
    
    if not message.startswith("b"):
        raise ValueError("The message should be a byte string (e.g., b'...').")
    else:
        message = binascii.unhexlify(message[1:])
        
    if not iv.startswith("b"):
        raise ValueError("The IV should be a byte string (e.g., b'...').")
    else:
        iv = binascii.unhexlify(iv[1:])

    # Build the client and connect to the server
    with client.ProxyKmipClient(config=config) as client:
        # Decrypt the cipher text with the encryption key.
                       
        try:
        
            if uuid:
                retrieved_id, retrieved_attributes = client.get_attributes(
                        uuid,
                        ["Cryptographic Algorithm"]        
                    )
                t_alg = next((x for x in retrieved_attributes if x.attribute_name.value == 'Cryptographic Algorithm'), None).attribute_value.value                    
        
            plain_text = client.decrypt(
                message,
                uid=uuid,
                cryptographic_parameters={
                    'cryptographic_algorithm': t_alg,
                    'block_cipher_mode': enums.BlockCipherMode[mode],
                    'padding_method': enums.PaddingMethod[padding]
                },
                iv_counter_nonce=iv
            )
            logger.info("Successfully decrypted the message.")
            logger.info("Plain text: '{0}'".format(plain_text.decode('utf-8')))
        except Exception as e:
            logger.error(e)
